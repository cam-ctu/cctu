
R version 4.5.1 (2025-06-13) -- "Great Square Root"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "cctu"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> base::assign(".ExTimings", "cctu-Ex.timings", pos = 'CheckExEnv')
> base::cat("name\tuser\tsystem\telapsed\n", file=base::get(".ExTimings", pos = 'CheckExEnv'))
> base::assign(".format_ptime",
+ function(x) {
+   if(!is.na(x[4L])) x[1L] <- x[1L] + x[4L]
+   if(!is.na(x[5L])) x[2L] <- x[2L] + x[5L]
+   options(OutDec = '.')
+   format(x[1L:3L], digits = 7L)
+ },
+ pos = 'CheckExEnv')
> 
> ### * </HEADER>
> library('cctu')

Attaching package: ‘cctu’

The following object is masked from ‘package:base’:

    source

> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("all_is_numeric")
> ### * all_is_numeric
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: all_is_numeric
> ### Title: Check if All Elements in Character Vector are Numeric
> ### Aliases: all_is_numeric
> 
> ### ** Examples
> 
> all_is_numeric(c("1", "1.2", "3"))
[1] TRUE
> all_is_numeric(c("1", "1.2", "3a"))
[1] FALSE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("all_is_numeric", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("apply_macro_dict")
> ### * apply_macro_dict
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: apply_macro_dict
> ### Title: Apply DLU/CLU file to the data frame
> ### Aliases: apply_macro_dict
> 
> ### ** Examples
> 
> 
> # Read MACRO data
> dt <- read.csv(system.file("extdata", "pilotdata.csv", package="cctu"),
+                colClasses = "character")
> dlu <- read.csv(system.file("extdata", "pilotdata_dlu.csv", package="cctu"))
> clu <- read.csv(system.file("extdata", "pilotdata_clu.csv", package="cctu"))
> 
> # Create subjid
> dt$subjid <- substr(dt$USUBJID, 8, 11)
> 
> df <- apply_macro_dict(dt, dlu = dlu, clu = clu, clean_names = FALSE)
> 
> # Following can give you the same dlu file used by apply_macro_dict
> dlu <- tidy_dlu(dlu, clean_names = FALSE)
> 
> # Extract data from Lab form
> lb <- extract_form(df, "Lab")
> 
> # Extract screening visit data from lab form
> lb_base <- extract_form(df, "Lab", visit = "SCREENING")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("apply_macro_dict", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("copy_lab")
> ### * copy_lab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: copy_lab
> ### Title: Copy variable label and value labels
> ### Aliases: copy_lab
> 
> ### ** Examples
> 
> var_with_lab <- rep(1:2, 5)
> var_lab(var_with_lab) <- "Income"
> val_lab(var_with_lab) <- c("Low" = 1, "High" = 2)
> var_nolab <- rep(1:2, 10)
> var_ut <- copy_lab(var_nolab, var_with_lab)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("copy_lab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("cttab")
> ### * cttab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: cttab
> ### Title: Generate an table of descriptive statistics.
> ### Aliases: cttab cttab.default cttab.formula
> 
> ### ** Examples
> 
> 
> # Read data
> dt <- read.csv(system.file("extdata", "pilotdata.csv", package="cctu"))
> dlu <- read.csv(system.file("extdata", "pilotdata_dlu.csv", package="cctu"))
> clu <- read.csv(system.file("extdata", "pilotdata_clu.csv", package="cctu"))
> 
> dt$subjid <- substr(dt$USUBJID, 8, 11)
> 
> # Apply variable attributes
> dt <- apply_macro_dict(dt, dlu, clu, clean_names = FALSE)
> 
> # Extract form data to be analysed
> df <- extract_form(dt, "PatientReg", vars_keep = c("subjid"))
> 
> ########################################################
> #  Simple analysis no group and variable subset
> ######################################################
> # Variable as a vector
> X <- cttab(x = c("AGE", "SEX", "BMIBL"),
+              data = df,
+              select = c("BMIBL" = "RACEN != 1"))
> 
> # Variable as a formula, equivalent to above
> X1 <- cttab(AGE + SEX + BMIBL ~ 1,
+             data = df,
+             select = c("BMIBL" = "RACEN != 1"))
> 
> #############################################
> #  Analysis by group
> ############################################
> # Variable as a vector
> X <- cttab(x = c("AGE", "SEX", "BMIBL"),
+              group = "ARM",
+              data = df,
+              select = c("BMIBL" = "RACEN != 1"))
> 
> ############################################
> # Analysis by group and cycles
> ############################################
> 
> df <- extract_form(dt, "Lab", vars_keep = c("subjid", "ARM"))
> 
> X <- cttab(x = c("AST", "BILI", "ALT"),
+                   group = "ARM",
+                   data = df,
+                   row_split = "AVISIT",
+                   select = c("ALT" = "PERF == 1"))
> 
> ############################################
> # Group variables
> ############################################
> 
> df <- extract_form(dt, "PatientReg", vars_keep = c("subjid"))
> base_lab <- extract_form(dt, "Lab", visit = "SCREENING", vars_keep = c("subjid"))
> 
> base_lab$ABNORMALT <- base_lab$ALT > 22.5
> var_lab(base_lab$ABNORMALT) <- "ALT abnormal"
> base_lab$ABNORMAST <- base_lab$AST > 25.5
> var_lab(base_lab$ABNORMAST) <- "AST abnormal"
> 
> df <- merge(df, base_lab, by = "subjid")
> 
> X <- cttab(x = list(c("AGE", "SEX", "BMIBL"),
+                       "Blood" = c("ALT", "AST"),
+                       "Patients with Abnormal" = c("ABNORMAST", "ABNORMALT")),
+           group = "ARM",
+           data = df,
+           select = c("BMIBL" = "RACEN != 1",
+                      "ALT" = "PERF == 1"))
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("cttab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("extract_form")
> ### * extract_form
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: extract_form
> ### Title: Extract data by form from MACRO dataset
> ### Aliases: extract_form
> 
> ### ** Examples
> 
> 
> # Read MACRO data
> dt <- read.csv(system.file("extdata", "pilotdata.csv", package="cctu"),
+                colClasses = "character")
> dlu <- read.csv(system.file("extdata", "pilotdata_dlu.csv", package="cctu"))
> clu <- read.csv(system.file("extdata", "pilotdata_clu.csv", package="cctu"))
> 
> # Create subjid
> dt$subjid <- substr(dt$USUBJID, 8, 11)
> 
> df <- apply_macro_dict(dt, dlu = dlu, clu = clu, clean_names = FALSE)
> 
> # Following can give you the same dlu file used by apply_macro_dict
> dlu <- tidy_dlu(dlu, clean_names = FALSE)
> 
> # Extract data from Lab form
> lb <- extract_form(df, "Lab")
> 
> # Extract screening visit data from lab form
> lb_base <- extract_form(df, "Lab", visit = "SCREENING")
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("extract_form", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("format_pval")
> ### * format_pval
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: format_pval
> ### Title: Format p-value
> ### Aliases: format_pval
> 
> ### ** Examples
> 
> pv <- c(-1, 0.00001, 0.0042, 0.0601, 0.1335, 0.4999, 0.51, 0.89, 0.9, 1)
> format_pval(pv)
 [1] "<0.001" "<0.001" "0.004"  "0.060"  "0.134"  "0.500"  "0.510"  "0.890" 
 [9] "0.900"  "1.000" 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("format_pval", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("geom_stepribbon")
> ### * geom_stepribbon
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: geom_stepribbon
> ### Title: Step ribbon plots.
> ### Aliases: geom_stepribbon GeomStepribbon
> ### Keywords: datasets
> 
> ### ** Examples
> 
> library(ggplot2)
> huron <- data.frame(year = 1875:1972, level = as.vector(LakeHuron))
> h <- ggplot(huron, aes(year))
> h + geom_stepribbon(
+   aes(
+     ymin = level - 1,
+     ymax = level + 1
+   ),
+   fill = "grey70"
+ ) +
+   geom_step(aes(y = level))
> h + geom_ribbon(aes(ymin = level - 1, ymax = level + 1), fill = "grey70") +
+   geom_line(aes(y = level))
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("geom_stepribbon", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:ggplot2’

> nameEx("get_obj")
> ### * get_obj
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: get_obj
> ### Title: Gets copies of objects from parent environments, or returns
> ###   alternative if not found
> ### Aliases: get_obj
> ### Keywords: internal
> 
> ### ** Examples
> 
> library(cctu)
> rm(PATH)
Warning in rm(PATH) : object 'PATH' not found
> cctu:::get_obj("PATH")
Warning in cctu:::get_obj("PATH") : PATH not found
NULL
> cctu:::get_obj("PATH", alt = getwd())
Warning in cctu:::get_obj("PATH", alt = getwd()) : PATH not found
[1] "/home/runner/work/cctu/cctu/check/cctu.Rcheck"
> PATH <- "C:/MyFile"
> cctu:::get_obj("PATH")
[1] "C:/MyFile"
> cctu:::get_obj("PATH", alt = getwd())
[1] "C:/MyFile"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("get_obj", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("is_empty")
> ### * is_empty
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: is_empty
> ### Title: Check whether string, list or vector is empty
> ### Aliases: is_empty
> 
> ### ** Examples
> 
> is_empty("test")
 test 
FALSE 
> is_empty("")
     
TRUE 
> is_empty(NA)
[1] TRUE
> is_empty(NULL)
[1] TRUE
> 
> # string is not empty
> is_empty(" ")
      
FALSE 
> 
> # however, this trimmed string is
> is_empty(trimws(" "))
     
TRUE 
> 
> # numeric vector
> x <- 1
> is_empty(x)
[1] FALSE
> x <- x[-1]
> is_empty(x)
[1] TRUE
> 
> # check multiple elements of character vectors
> is_empty(c("", "a"))
          a 
 TRUE FALSE 
> 
> # empty data frame
> d <- data.frame()
> is_empty(d)
[1] TRUE
> 
> # empty list
> # is_empty(list(NULL))
> 
> # NA vector
> x <- rep(NA, 5)
> is_empty(x)
[1] TRUE TRUE TRUE TRUE TRUE
> is_empty(x, na_empty = FALSE)
[1] FALSE FALSE FALSE FALSE FALSE
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("is_empty", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("km_ggplot")
> ### * km_ggplot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: km_ggplot
> ### Title: Create a Kaplan-Meier plot using ggplot2
> ### Aliases: km_ggplot
> 
> ### ** Examples
> 
> library(survival)
> fit <- survfit(Surv(time, status) ~ rx, data = colon)
> km_ggplot(fit)
> ## Change theme of the KM-plot
> p <- km_ggplot(fit)
> p$top <- p$top +
+   ggplot2::theme_classic()
> # Change the theme of the risktable
> p$bottom <- p$bottom +
+   ggplot2::theme_void()
> 
> plot(p)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("km_ggplot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:survival’

> nameEx("lab2val")
> ### * lab2val
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: lab2val
> ### Title: Replace vector/matrix/data.frame values with corresponding value
> ###   labels.
> ### Aliases: lab2val
> 
> ### ** Examples
> 
> data(mtcars)
> mtcars <- within(mtcars, {
+   var_lab(mpg) <- NULL
+   val_lab(am) <- c(" automatic" = 0, " manual" = 1)
+ })
> 
> table(lab2val(mtcars$am))

 automatic     manual 
        19         13 
> 
> summary(lm(mpg ~ ., data = lab2val(mtcars[, c("mpg", "am")])))

Call:
lm(formula = mpg ~ ., data = lab2val(mtcars[, c("mpg", "am")]))

Residuals:
    Min      1Q  Median      3Q     Max 
-9.3923 -3.0923 -0.2974  3.2439  9.5077 

Coefficients:
            Estimate Std. Error t value Pr(>|t|)    
(Intercept)   17.147      1.125  15.247 1.13e-15 ***
am manual      7.245      1.764   4.106 0.000285 ***
---
Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1

Residual standard error: 4.902 on 30 degrees of freedom
Multiple R-squared:  0.3598,	Adjusted R-squared:  0.3385 
F-statistic: 16.86 on 1 and 30 DF,  p-value: 0.000285

> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("lab2val", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("merge_data")
> ### * merge_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: merge_data
> ### Title: Merge vertically split data
> ### Aliases: merge_data
> 
> ### ** Examples
> 
> 
> # Read example data
> dt_a <- read.csv(system.file("extdata", "test_A.csv", package="cctu"),
+                  colClasses = "character")
> dt_b <- read.csv(system.file("extdata", "test_B.csv", package="cctu"),
+                  colClasses = "character")
> 
> # Read DLU and CLU
> dlu_a <- read.csv(system.file("extdata", "test_A_DLU.csv", package="cctu"))
> dlu_b <- read.csv(system.file("extdata", "test_B_DLU.csv", package="cctu"))
> clu_a <- read.csv(system.file("extdata", "test_A_CLU.csv", package="cctu"))
> clu_b <- read.csv(system.file("extdata", "test_B_CLU.csv", package="cctu"))
> 
> # Merge dataset with merge_data function
> res <- merge_data(datalist = list(dt_a, dt_b), dlulist = list(dlu_a, dlu_b),
+                   clulist = list(clu_a, clu_b))
> dt <- res$data # Extract combined data
> dlu <- res$dlu # Extract combined DLU data
> clu <- res$clu # Extract combined CLU data
> 
> # Apply CLU and DLU files
> dt <- apply_macro_dict(dt, dlu = dlu, clu = clu, clean_names = FALSE)
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("merge_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("num_stat")
> ### * num_stat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: num_stat
> ### Title: Compute some basic descriptive statistics.
> ### Aliases: num_stat cat_stat
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- exp(rnorm(100, 1, 1))
> num_stat(x)
$N
[1] "100"

$NMISS
[1] "0"

$SUM
[1] "448"

$MEAN
[1] "4.48"

$SD
[1] "4.68"

$CV
[1] "104.5%"

$GMEAN
[1] "3.03"

$GCV
[1] "111.4%"

$GSD
[1] "2.46"

$MEDIAN
[1] "3.05"

$MIN
[1] "0.297"

$Q1
   25% 
"1.66" 

$Q2
   50% 
"3.05" 

$Q3
   75% 
"5.43" 

$IQR
   75% 
"3.77" 

$MAX
[1] "30.0"

> 
> y <- factor(sample(0:1, 99, replace = TRUE), labels = c("Female", "Male"))
> y[1:10] <- NA
> cat_stat(y)
$Female
$Female$FREQ
[1] 40

$Female$PCT
[1] "40.4%"

$Female$PCTnoNA
[1] "44.9%"

$Female$Nall
[1] 99

$Female$N
[1] 89


$Male
$Male$FREQ
[1] 49

$Male$PCT
[1] "49.5%"

$Male$PCTnoNA
[1] "55.1%"

$Male$Nall
[1] 99

$Male$N
[1] 89


> cat_stat(is.na(y))
$Yes
$Yes$FREQ
[1] 10

$Yes$PCT
[1] "10.1%"

$Yes$PCTnoNA
[1] "10.1%"

$Yes$Nall
[1] 99

$Yes$N
[1] 99


$No
$No$FREQ
[1] 89

$No$PCT
[1] "89.9%"

$No$PCTnoNA
[1] "89.9%"

$No$Nall
[1] 99

$No$N
[1] 99


> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("num_stat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("p_format")
> ### * p_format
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: p_format
> ### Title: formats p values with rounding and <0.001
> ### Aliases: p_format
> 
> ### ** Examples
> 
> p_format(c(0.000001, 0.451234))
[1] "<0.001" " 0.451"
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("p_format", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("plot.code_tree")
> ### * plot.code_tree
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: plot.code_tree
> ### Title: plot the code tree.
> ### Aliases: plot.code_tree
> 
> ### ** Examples
> 
> ## Not run: 
> ##D plot(get_code_tree(), root_file = "main.R")
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("plot.code_tree", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
> nameEx("read_data")
> ### * read_data
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: read_data
> ### Title: Automatic reading in data from a meta-table of external data
> ###   sets.
> ### Aliases: read_data read_data.data.frame read_data.character
> 
> ### ** Examples
> 
> data_table <- data.frame(
+   name = c("dirtydata", "meta"),
+   file = c("dirtydata.csv", "meta_table.xlsx"),
+   folder = system.file("extdata", package = "cctu"),
+   stringsAsFactors = FALSE
+ )
> data_table_summary(data_table)
       name            file
1 dirtydata   dirtydata.csv
2      meta meta_table.xlsx
                                                      folder
1 /home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu/extdata
2 /home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu/extdata
             mod_time
1 2025-06-19 12:23:06
2 2025-06-19 12:23:06
                                                              full_file_path
1   /home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu/extdata/dirtydata.csv
2 /home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu/extdata/meta_table.xlsx
> options("verbose" = TRUE)
> read_data(data_table)
object created in R_GlobalEnv: dirtydata
now dyn.load("/home/runner/work/_temp/Library/readxl/libs/readxl.so") ...
object created in R_GlobalEnv: meta
> summary(dirtydata)
   Subject_Id        age           gender            Treatment  
 Min.   :1.00   Min.   :19.00   Length:8           Min.   :1.0  
 1st Qu.:2.25   1st Qu.:24.50   Class :character   1st Qu.:1.0  
 Median :3.50   Median :40.00   Mode  :character   Median :1.5  
 Mean   :3.50   Mean   :38.33                      Mean   :1.5  
 3rd Qu.:4.75   3rd Qu.:51.75                      3rd Qu.:2.0  
 Max.   :6.00   Max.   :56.00                      Max.   :2.0  
 NA's   :2      NA's   :2                          NA's   :2    
  start_date           outcome    missing        comments      
 Length:8           Min.   :0.0   Mode:logical   Mode:logical  
 Class :character   1st Qu.:0.0   NA's:8         NA's:8        
 Mode  :character   Median :0.5                                
                    Mean   :0.5                                
                    3rd Qu.:1.0                                
                    Max.   :1.0                                
                    NA's   :2                                  
> summary(meta)
  Completed         Checked          Section             Title          
 Length:4           Mode:logical   Length:4           Length:4          
 Class :character   NA's:4         Class :character   Class :character  
 Mode  :character                  Mode  :character   Mode  :character  
                                                                        
                                                                        
                                                                        
                                                                        
   Subtitle            Number           Population        Orientation       
 Length:4           Length:4           Length:4           Length:4          
 Class :character   Class :character   Class :character   Class :character  
 Mode  :character   Mode  :character   Mode  :character   Mode  :character  
                                                                            
                                                                            
                                                                            
                                                                            
 Program            Item             Junk         Endpoint      
 Mode:logical   Length:4           Mode:logical   Mode:logical  
 NA's:4         Class :character   NA's:4         NA's:4        
                Mode  :character                                
                                                                
                                                                
                                                                
                                                                
 Time Points or how to conglomerate Covariates or Subgroups Summary Statistics
 Length:4                           Length:4                Length:4          
 Class :character                   Class :character        Class :character  
 Mode  :character                   Mode  :character        Mode  :character  
                                                                              
                                                                              
                                                                              
                                                                              
 Formal Analysis  Footnote1         Footnote2         fontsize 
 Mode:logical    Length:4           Mode:logical   Min.   :16  
 NA's:4          Class :character   NA's:4         1st Qu.:17  
                 Mode  :character                  Median :18  
                                                   Mean   :18  
                                                   3rd Qu.:19  
                                                   Max.   :20  
                                                   NA's   :1   
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("read_data", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 64 = 40+4+20 (level 2) ... 
133.2 Mbytes of cons cells used (56%)
35.0 Mbytes of vectors used (45%)
> nameEx("regression_table")
> ### * regression_table
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: regression_table
> ### Title: Produce a table summarising a regression model for a study
> ###   report
> ### Aliases: regression_table
> 
> ### ** Examples
> 
> library(survival)
> cfit1 <- coxph(Surv(time, status) ~ age + sex + wt.loss, data = lung)
> regression_table(cfit1,
+   digits = 4,
+   labels = c(
+     "Age (per year)", "Sex (Female vs Male)",
+     "Weight loss (per pound)"
+   )
+ )
                Parameter          Log HR (SE)     HR     Conf. Int. p-value
1          Age (per year)   0.02009 (0.009664)  1.020   1.001, 1.040  0.0377
2    Sex (Female vs Male)     -0.5210 (0.1744) 0.5939 0.4220, 0.8359  0.0028
3 Weight loss (per pound) 0.0007596 (0.006193)  1.001  0.9887, 1.013  0.9024
4                                                                           
5  Number of Observations                  214                              
6        Number of Events                  152                              
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("regression_table", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()

detaching ‘package:survival’

Garbage collection 65 = 40+4+21 (level 2) ... 
134.2 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("render_cat")
> ### * render_cat
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: render_cat
> ### Title: Render categorical values for table output.
> ### Aliases: render_cat
> ### Keywords: utilities
> 
> ### ** Examples
> 
> y <- factor(sample(0:1, 99, replace = TRUE), labels = c("Female", "Male"))
> y[1:10] <- NA
> render_cat(y)
         Female            Male 
"42/89 (47.2%)" "47/89 (52.8%)" 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("render_cat", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 66 = 40+4+22 (level 2) ... 
134.2 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("render_numeric")
> ### * render_numeric
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: render_numeric
> ### Title: Render continuous values for table output.
> ### Aliases: render_numeric
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- exp(rnorm(100, 1, 1))
> render_numeric(x)
          Valid Obs.            Mean (SD)    Median [Min, Max] 
               "100"        "4.48 (4.68)" "3.05 [0.297, 30.0]" 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("render_numeric", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 67 = 40+4+23 (level 2) ... 
134.2 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("signif_pad")
> ### * signif_pad
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: signif_pad
> ### Title: Round numbers with 0-padding.
> ### Aliases: signif_pad round_pad
> ### Keywords: utilities
> 
> ### ** Examples
> 
> x <- c(0.9001, 12345, 1.2, 1., 0.1, 0.00001, 1e5)
> signif_pad(x, digits = 3)
[1] "0.900"     "12300"     "1.20"      "1.00"      "0.100"     "0.0000100"
[7] "100000"   
> signif_pad(x, digits = 3, round.integers = TRUE)
[1] "0.900"     "12300"     "1.20"      "1.00"      "0.100"     "0.0000100"
[7] "100000"   
> round_pad(x, digits = 2)
[1] "0.90"      "12345.00"  "1.20"      "1.00"      "0.10"      "0.00"     
[7] "100000.00"
> 
> # Compare:
> as.character(signif(x, digits = 3))
[1] "0.9"   "12300" "1.2"   "1"     "0.1"   "1e-05" "1e+05"
> format(x, digits = 3, nsmall = 3)
[1] "9.00e-01" "1.23e+04" "1.20e+00" "1.00e+00" "1.00e-01" "1.00e-05" "1.00e+05"
> prettyNum(x, digits = 3, drop0trailing = TRUE)
[1] "0.9"   "12345" "1.2"   "1"     "0.1"   "1e-05" "1e+05"
> prettyNum(x, digits = 3, drop0trailing = FALSE)
[1] "0.9"   "12345" "1.2"   "1"     "0.1"   "1e-05" "1e+05"
> 
> # This is very close.
> formatC(x, format = "fg", flag = "#", digits = 3)
[1] "0.900"     "12345."    "1.20"      "1.00"      "0.100"     "0.0000100"
[7] "100000."  
> formatC(signif(x, 3), format = "fg", flag = "#", digits = 3)
[1] "0.900"     "12300."    "1.20"      "1.00"      "0.100"     "0.0000100"
[7] "100000."  
> 
> # Could always remove the trailing "."
> sub("[.]$", "", formatC(x, format = "fg", flag = "#", digits = 3))
[1] "0.900"     "12345"     "1.20"      "1.00"      "0.100"     "0.0000100"
[7] "100000"   
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("signif_pad", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 68 = 40+4+24 (level 2) ... 
134.2 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("to_factor")
> ### * to_factor
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: to_factor
> ### Title: Convert vector but keep value/value labels.
> ### Aliases: to_factor to_character to_numeric to_logical
> 
> ### ** Examples
> 
> data(mtcars)
Warning in find.package(package, lib.loc, verbose = verbose) :
  package ‘cctu’ found more than once, using the first from
  “/home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu”,
  “/tmp/RtmpknFxzd/RLIBS_2106742b184f/cctu”
name=mtcars:	 NOT found in names() of Rdata.rds, i.e.,
	meta_table_example

name=mtcars:	 found in Rdata.rds
> mtcars <- within(mtcars, {
+   var_lab(am) <- "Transmission"
+   val_lab(am) <- c(" automatic" = 0, " manual" = 1)
+ })
> 
> mtcars$am <- to_factor(mtcars$am)
> mtcars$gear <- to_character(mtcars$gear)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("to_factor", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 69 = 40+4+25 (level 2) ... 
134.3 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("unlab")
> ### * unlab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: unlab
> ### Title: Drop variable label and value labels
> ### Aliases: unlab
> 
> ### ** Examples
> 
> raw_var <- rep(1:2, 5)
> var_with_lab <- raw_var
> var_lab(var_with_lab) <- "Income"
> val_lab(var_with_lab) <- c("Low" = 1, "High" = 2)
> identical(raw_var, unlab(var_with_lab)) # should be TRUE
[1] TRUE
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("unlab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 70 = 40+4+26 (level 2) ... 
134.3 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("val_lab")
> ### * val_lab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: val_lab
> ### Title: Set or get value labels
> ### Aliases: val_lab val_lab<- has.labels unval
> 
> ### ** Examples
> 
> # toy example
> set.seed(123)
> # score - evaluation of tested product
> 
> score <- sample(-1:1, 20, replace = TRUE)
> var_lab(score) <- "Evaluation of tested brand"
> val_lab(score) <- c(
+   "Dislike it" = -1,
+   "So-so" = 0,
+   "Like it" = 1
+ )
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("val_lab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 71 = 40+4+27 (level 2) ... 
134.3 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("var_lab")
> ### * var_lab
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: var_lab
> ### Title: Set or get variable label
> ### Aliases: var_lab var_lab.data.frame var_lab<- has.label drop_lab
> 
> ### ** Examples
> 
> data(mtcars)
Warning in find.package(package, lib.loc, verbose = verbose) :
  package ‘cctu’ found more than once, using the first from
  “/home/runner/work/cctu/cctu/check/cctu.Rcheck/cctu”,
  “/tmp/RtmpknFxzd/RLIBS_2106742b184f/cctu”
name=mtcars:	 NOT found in names() of Rdata.rds, i.e.,
	meta_table_example

name=mtcars:	 found in Rdata.rds
> mtcars <- within(mtcars, {
+   var_lab(mpg) <- "Miles/(US) gallon"
+   var_lab(cyl) <- "Number of cylinders"
+   var_lab(disp) <- "Displacement (cu.in.)"
+   var_lab(hp) <- "Gross horsepower"
+   var_lab(drat) <- "Rear axle ratio"
+   var_lab(wt) <- "Weight (lb/1000)"
+   var_lab(qsec) <- "1/4 mile time"
+   var_lab(vs) <- "V/S"
+   val_lab(vs) <- c("V-shaped" = 0, "straight" = 1)
+   var_lab(am) <- "Transmission"
+   val_lab(am) <- c(automatic = 0, manual = 1)
+   var_lab(gear) <- "Number of forward gears"
+   var_lab(carb) <- "Number of carburetors"
+ })
> 
> table(mtcars$am)

 0  1 
19 13 
> 
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("var_lab", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> cleanEx()
Garbage collection 72 = 40+4+28 (level 2) ... 
134.3 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> nameEx("write_plot")
> ### * write_plot
> 
> flush(stderr()); flush(stdout())
> 
> base::assign(".ptime", proc.time(), pos = "CheckExEnv")
> ### Name: write_plot
> ### Title: Function to save plot figures
> ### Aliases: write_plot
> 
> ### ** Examples
> 
> ## Not run: 
> ##D #####################################
> ##D # Below is a simple example ========#
> ##D #####################################
> ##D #
> ##D write_plot(plot_fn = plot, plot_args = list(x = iris[, 1], y = iris[, 2]))
> ##D # This is equivalent drawing the following plot and save it
> ##D plot(x = iris[, 1], y = iris[, 2])
> ##D 
> ##D # Below is user defined function plotting
> ##D # One can use this method to draw a complicated plot
> ##D new_plot <- function(x, y, h, v) {
> ##D   par(pty = "s", cex = 0.7) # adjust plot style
> ##D   plot(x, y)
> ##D   abline(h = h, v = v, lty = 2) # add some lines
> ##D }
> ##D write_plot(
> ##D   x = iris[, 1], y = iris[, 2], h = 2.5, v = 6.0,
> ##D   plot_fn = new_plot
> ##D )
> ##D 
> ##D 
> ##D ####################################################
> ##D # To draw a KM-plot from survminer package ========#
> ##D ####################################################
> ##D 
> ##D library("survival")
> ##D library("survminer")
> ##D fit <- survfit(Surv(time, status) ~ sex, data = lung)
> ##D # Drawing survival curves
> ##D p <- ggsurvplot(fit, data = lung)
> ##D write_plot(p, plot_fn = survminer:::print.ggsurvplot)
> ##D # The code above works because the p is a ggsurvplot object (check it with class(p))
> ##D # There's a printing function print.ggsurvplot to handle the printing of the KM-plot.
> ##D # But this function is not exported by survminer, so we need to use three colons.
> ##D 
> ##D #####################################
> ##D # Draw a consort diagram ===========#
> ##D #####################################
> ##D 
> ##D library(grid)
> ##D # Might want to change some settings
> ##D txt0 <- c("Study 1 (n=160)", "Study 2 (n=140)")
> ##D txt1 <- "Population (n=300)"
> ##D txt1_side <- "Excluded (n=15):\n\u2022 MRI not collected (n=15)"
> ##D 
> ##D # supports pipeline operator
> ##D g <- add_box(txt = txt0) |>
> ##D   add_box(txt = txt1) |>
> ##D   add_side_box(txt = txt1_side) |>
> ##D   add_box(txt = "Randomized (n=200)")
> ##D # Since you can draw the plot g with plot(g), the ploting function is plot
> ##D # The plotting function is \code{plot.consort}, so simple plot or plot.consort works
> ##D write_plot(g, plot_fn = plot)
> ##D # Or just
> ##D write_plot(g)
> ## End(Not run)
> 
> 
> 
> base::assign(".dptime", (proc.time() - get(".ptime", pos = "CheckExEnv")), pos = "CheckExEnv")
> base::cat("write_plot", base::get(".format_ptime", pos = 'CheckExEnv')(get(".dptime", pos = "CheckExEnv")), "\n", file=base::get(".ExTimings", pos = 'CheckExEnv'), append=TRUE, sep="\t")
> ### * <FOOTER>
> ###
> cleanEx()
Garbage collection 73 = 40+4+29 (level 2) ... 
134.3 Mbytes of cons cells used (57%)
35.4 Mbytes of vectors used (46%)
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  8.664 0.129 8.786 0 0 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
> ### End: ***
> quit('no')
